from sklearn.linear_model import LinearRegression
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn import metrics
from sklearn.model_selection import cross_validate
from sklearn.model_selection import cross_val_score
from sklearn.tree import export_graphviz

#!/usr/bin/env python
# coding: utf-8

# In[1]:


import pandas as pd


# ## Analysis of Random Sample of 1 million leavetimes merged with trips data

# In[2]:


df1 = pd.read_csv('../../data/leavetimes_trips_1e6.csv',sep=',')


# In[3]:


df1.head()


# In[4]:


df1.drop('Unnamed: 0',axis=1,inplace=True)


# In[5]:


# dtypes 
df1['DATASOURCE'] = df1['DATASOURCE'].astype('category')
df1['DAYOFSERVICE'] = df1['DAYOFSERVICE'].astype('datetime64')
df1['TRIPID'] = df1['TRIPID'].astype('object')
df1['PROGRNUMBER'] = df1['PROGRNUMBER'].astype('category')
df1['STOPPOINTID'] = df1['STOPPOINTID'].astype('category')
df1['VEHICLEID'] = df1['VEHICLEID'].astype('object')
df1['SUPPRESSED_x'] = df1['SUPPRESSED_x'].astype('category')
df1['JUSTIFICATIONID_x'] = df1['JUSTIFICATIONID_x'].astype('category')
df1['DIRECTION'] = df1['DIRECTION'].astype('category')
df1['SUPPRESSED_y'] = df1['SUPPRESSED_y'].astype('category')
df1['JUSTIFICATIONID_y'] = df1['JUSTIFICATIONID_y'].astype('category')
df1['TENDERLOT'] = df1['TENDERLOT'].astype('category')
df1['NOTE_x'] = df1['NOTE_x'].astype('category')
df1['PASSENGERS'] = df1['PASSENGERS'].astype('category')
df1['PASSENGERSIN'] = df1['PASSENGERSIN'].astype('category')
df1['PASSENGERSOUT'] = df1['PASSENGERSOUT'].astype('category')
df1['DISTANCE'] = df1['DISTANCE'].astype('category')
df1['NOTE_y'] = df1['DISTANCE'].astype('category')
df1['LASTUPDATE_x'] = df1['LASTUPDATE_x'].astype('datetime64')
df1['LASTUPDATE_y'] = df1['LASTUPDATE_y'].astype('datetime64')
df1['BASIN'] = df1['BASIN'].astype('category')
df1['LINEID'] = df1['LINEID'].astype('category')


# In[6]:


df1.dtypes


# In[7]:


categorical_columns = df1.select_dtypes('category').columns
numerical_columns = df1.select_dtypes('int64','float64').columns
object_columns = df1.select_dtypes('object').columns


# In[8]:


df1[categorical_columns].describe().T


# In[9]:


df1.drop(['PASSENGERS','PASSENGERSIN','PASSENGERSOUT','DISTANCE','NOTE_x'],axis=1,inplace=True)


# In[10]:


categorical_columns = df1.select_dtypes('category').columns


# In[11]:


df1[categorical_columns].describe().T


# In[12]:


df1.drop(['DATASOURCE','TENDERLOT','NOTE_y','BASIN','SUPPRESSED_y','JUSTIFICATIONID_y'],axis=1,inplace=True)


# In[13]:


categorical_columns = df1.select_dtypes('category').columns


# In[14]:


df1[categorical_columns].describe().T


# In[15]:


df1.head()


# In[16]:


df1_simple = df1.drop([
    'LASTUPDATE_y',
    'ROUTEID',
    'LASTUPDATE_x',
    'JUSTIFICATIONID_x',
    'SUPPRESSED_x',
    'ACTUALTIME_DEP',
    'TRIPID',
    'VEHICLEID',
    'PLANNEDTIME_DEP',
    'PROGRNUMBER'
],axis=1)


# In[17]:


df1_simple.head()


# In[18]:


df1_simple.dtypes


# In[24]:


df1_simple['MONTH'] = df1_simple['DAYOFSERVICE'].dt.month.astype('category')
df1_simple['WEEKDAY'] = df1_simple['DAYOFSERVICE'].dt.weekday.astype('category')
df1_simple.drop('DAYOFSERVICE',axis=1,inplace=True)


# In[25]:


df1_simple.head()


# In[26]:


df1_simple.dtypes


# In[ ]:


df1_simple.head()

categorical_columns = df1_simple.select_dtypes('category').columns
df1_simple[categorical_columns].describe().T

df1_simple_46A = df1_simple[df1_simple['LINEID'] == '46A']

df1_simple_46A.shape[0]/130

df1_simple_46A[categorical_columns].describe().T

df1_simple_46A.drop('LINEID',axis=1,inplace=True)
df_rev1 = pd.get_dummies(df1_simple_46A)

continuous_columns = df_rev1.select_dtypes(include=['int64']).columns.tolist()
# remove the target "binary_outcome"
continuous_columns

categorical_columns = df_rev1.select_dtypes(include=['uint8']).columns.tolist()
categorical_columns

# y is the target
y = df_rev1["ACTUALTIME_ARR"]
# X is everything else
X = df_rev1.drop(["ACTUALTIME_ARR"],1)
# Split the dataset into two datasets: 70% training and 30% test
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1,  test_size=0.3)

print("original range is: ",df_rev1.shape[0])
print("training range (70%):\t rows 0 to", round(X_train.shape[0]))
print("test range (30%): \t rows", round(X_train.shape[0]), "to", round(X_train.shape[0]) + X_test.shape[0])

# need to reset the index to allow contatenation with predicted values otherwise not joining on same index...
X_train.reset_index(drop=True, inplace=True)
y_train.reset_index(drop=True, inplace=True)
X_test.reset_index(drop=True, inplace=True)
y_test.reset_index(drop=True, inplace=True)
X_train.head(5)

# Train aka fit, a model using all continuous and categorical features.
multiple_linreg = LinearRegression().fit(X_train, y_train)

# Print the weights learned for each feature.
print("\nFeatures are: \n", X_train.columns)
print("\nCoeficients are: \n", multiple_linreg.coef_)
print("\nIntercept is: \n", multiple_linreg.intercept_)
print("\nFeatures and coeficients: \n")#, list(zip(X_train.columns, multiple_linreg.coef_)))
for i in list(zip(X_train.columns,multiple_linreg.coef_)):
    print("{:e}".format(i[1]), i[0])

# calculate the prediction and threshold the value. If >= 0.5 its true
multiple_linreg_predictions_train = multiple_linreg.predict(X_train)
actual_vs_predicted_multiplelinreg = pd.concat([y_train, pd.DataFrame(multiple_linreg_predictions_train, columns=['Predicted'])], axis=1)

print("\nUnthresholded predictions with multiple linear regression: \n")
print(actual_vs_predicted_multiplelinreg.head(10))
print()

#This function is used repeatedly to compute all metrics
def printMetrics(testActualVal, predictions):
    #classification evaluation measures
    print('\n==============================================================================')
    print("MAE: ", metrics.mean_absolute_error(testActualVal, predictions))
    #print("MSE: ", metrics.mean_squared_error(testActualVal, predictions))
    print("RMSE: ", metrics.mean_squared_error(testActualVal, predictions)**0.5)
    print("R2: ", metrics.r2_score(testActualVal, predictions))

printMetrics(y_train, multiple_linreg_predictions_train)

# Predicted price on test set
test_predictions = multiple_linreg.predict(X_test)
print("Actual values of test:\n", y_test)
print("Predictions on test:", test_predictions)
printMetrics(y_test, test_predictions)


